 /*
  * Unitex
  *
  * Copyright (C) 2001-2008 Université Paris-Est Marne-la-Vallée <unitex@univ-mlv.fr>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
  * version 2.1 of the License, or (at your option) any later version.
  *
  * This library is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  * 
  * You should have received a copy of the GNU Lesser General Public
  * License along with this library; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.
  *
  */
  
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "ConcordMain.h"
#include "Unicode.h"
#include "Text_tokens.h"
#include "String_hash.h"
#include "List_int.h"
#include "Alphabet.h"
#include "Matches.h"
#include "Concordance.h"
#include "File.h"
#include "Copyright.h"
#include "LocatePattern.h"
#include "Error.h"
#include "Snt.h"
#include "Copyright.h"
#include "getopt.h"


/* Maximum number of new lines in a text. New lines are encoded in
 * 'enter.pos' files. Those files will disappear in the future */
#define MAX_ENTER_CHAR 1000000
int enter_pos[MAX_ENTER_CHAR];



void usage_() {
u_printf("%S",COPYRIGHT);
u_printf("Usage: Concord [OPTIONS] <concor>\n"
       "   <concord> : the concord.ind file generated by the locate program\n"
       "   <font> : the font you want to use\n"
       "   <fontsize> : the font size\n"
       "   <l> : left context length in chars\n"
       "   <r> : right context length in chars\n"
       "       (add \"s\" to right or left context length, e.g. \"80s\",\n"
       "        to stop at first \"{S}\")\n"
       "   <order> : sort order:\n"
       "           TO : text order\n"
       "           LC : left, center\n"
       "           LR : left, right\n"
       "           CL : center, left\n"
       "           CR : center, right\n"
       "           RL : right, left\n"
       "           RC : right, center\n"
       "           NULL : specifies no order (used for non-html <mode>)\n"
       "   <mode> : the mode to be used:\n"
       "            html : produces an HTML concordance file\n"
       "            text : produces a plain text concordance file\n"
       "            glossanet=<script> : produces a glossanet HTML concordance file\n"
       "            index : produces an index of the concordance\n"
       "            uima : produces another index of the concordance\n"
       "            axis : produces an axis file for the concordance (cf. [Melamed 06])\n"
       "            xalign : produces an index file for XAlign display\n"
       "            (txt) : produces a file named (txt) which is the SNT file\n"
       "                    merged with the match results\n"
       "   <alph> : the char order file used for sorting\n"
       "            NULL if no alphabet is given\n"
       "   [-thai] : option to use for thai concordances\n"
       "\nExtracts the matches stored in <concor>, and stores them into a UTF-8\n"
       "HTML file saved in the <concor> directory or produces a text file, according\n"
       "to the <mode> parameter\n"
       "\nExamples:\n"
       "Concord tutu.ind \"Courier New\" 12 40 40 TO html \"d:\\My dir\\alph.txt\"\n"
       "    -> produces an HTML file\n"
       "\n"
       "Concord tutu.ind NULL 0 0 0 NULL \"C:\\My dir\\RES.SNT\" NULL\n"
       "    -> produces a text file named \"C:\\My dir\\RES.SNT\"\n");
}





/**
 * The same than main, but no call to setBufferMode.
 */
int main_Concord(int argc, char **argv) {
if (argc==1) {
   usage_();
   return 0;
}

const char* optstring=":f:s:l:r:Htg:iuAxm:a:Td:h";
const struct option lopts[]= {
      {"font",required_argument,NULL,'f'},
      {"fontsize",required_argument,NULL,'s'},
      {"left",required_argument,NULL,'l'},
      {"right",required_argument,NULL,'r'},
      {"TO",no_argument,NULL,0},
      {"LC",no_argument,NULL,1},
      {"LR",no_argument,NULL,2},
      {"CL",no_argument,NULL,3},
      {"CR",no_argument,NULL,4},
      {"RL",no_argument,NULL,5},
      {"RC",no_argument,NULL,6},
      {"html",no_argument,NULL,'H'},
      {"text",no_argument,NULL,'t'},
      {"glossanet",required_argument,NULL,'g'},
      {"index",no_argument,NULL,'i'},
      {"uima",no_argument,NULL,'u'},
      {"axis",no_argument,NULL,'A'},
      {"xalign",no_argument,NULL,'x'},
      {"merge",required_argument,NULL,'m'},
      {"alphabet",required_argument,NULL,'a'},
      {"thai",no_argument,NULL,'T'},
      {"dir",required_argument,NULL,'d'},
      {"help",no_argument,NULL,'h'},
      {NULL,no_argument,NULL,0}
};
int val,index=-1;
struct conc_opt* options=new_conc_opt();
char foo;
int ret;
while (EOF!=(val=getopt_long(argc,argv,optstring,lopts,&index))) {
   switch(val) {
   case 'f': if (optarg[0]=='\0') {
                fatal_error("Empty font name argument\n");
             }
             options->fontname=strdup(optarg); 
             break;
   case 's': if (1!=sscanf(optarg,"%d%c",&(options->fontsize),&foo)) {
                /* foo is used to check that the font size is not like "45gjh" */
                fatal_error("Invalid font size argument: %s\n",optarg);
             }
             break;
   case 'l': ret=sscanf(optarg,"%d%c%c",&(options->left_context),&foo,&foo);
             if (ret==0 || ret==3 || (ret==2 && foo!='s') || options->left_context<0) {
                fatal_error("Invalid left context argument: %s\n",optarg);
             }
             if (ret==2) {
                options->left_context_until_eos=1;
             }
             break;
   case 'r': ret=sscanf(optarg,"%d%c%c",&(options->right_context),&foo,&foo);
             if (ret==0 || ret==3 || (ret==2 && foo!='s') || options->right_context<0) {
                fatal_error("Invalid right context argument: %s\n",optarg);
             }
             if (ret==2) {
                options->right_context_until_eos=1;
             }
             break;
   case 0: options->sort_mode=TEXT_ORDER; break;
   case 1: options->sort_mode=LEFT_CENTER; break;
   case 2: options->sort_mode=LEFT_RIGHT; break;
   case 3: options->sort_mode=CENTER_LEFT; break;
   case 4: options->sort_mode=CENTER_RIGHT; break;
   case 5: options->sort_mode=RIGHT_LEFT; break;
   case 6: options->sort_mode=RIGHT_CENTER; break;
   case 'H': options->result_mode=HTML_; break;
   case 't': options->result_mode=TEXT_; break;
   case 'g': options->result_mode=GLOSSANET_;
             if (optarg[0]=='\0') {
                fatal_error("Empty glossanet script argument\n");
             }
             options->glossanet_script=strdup(optarg);
             break;
   case 'i': options->result_mode=INDEX_; break;
   case 'u': options->result_mode=UIMA_; break;
   case 'A': options->result_mode=AXIS_; break;
   case 'x': options->result_mode=XALIGN_; break;
   case 'm': options->result_mode=MERGE_;
             if (optarg[0]=='\0') {
                fatal_error("Empty output file name argument\n");
             }
             strcpy(options->output,optarg);
             break;
   case 'a': if (optarg[0]=='\0') {
                fatal_error("Empty alphabet argument\n");
             }
             options->sort_alphabet=strdup(optarg);
             break;
   case 'T': options->thai_mode=1; break;
   case 'd': if (optarg[0]=='\0') {
                fatal_error("Empty snt directory argument\n");
             }
             strcpy(options->working_directory,optarg);
             break;
   case 'h': usage_(); return 0;
   case ':': if (index==-1) fatal_error("Missing argument for option -%c\n",optopt); 
             else fatal_error("Missing argument for option --%s\n",lopts[index].name);
   case '?': if (index==-1) fatal_error("Invalid option -%c\n",optopt); 
             else fatal_error("Invalid option --%s\n",optarg);
             break;
   }
   index=-1;
}

if (optind!=argc-1) {
   error("Invalid arguments: rerun with --help\n");
   return 1;
}

if (options->fontname==NULL || options->fontsize<=0) {
   if (options->result_mode==HTML_ || options->result_mode==GLOSSANET_) {
      fatal_error("The specified output mode is an HTML file: you must specify font parameters\n");
   }
}
FILE* concor=u_fopen(argv[optind],U_READ);
if (concor==NULL) {
   error("Cannot open concordance index file %s\n",argv[optind]);
   return 1;
}

if (options->working_directory[0]=='\0') {
   get_path(argv[optind],options->working_directory);
}
/* We compute the name of the files associated to the text */
struct snt_files* snt_files=new_snt_files_from_path(options->working_directory);
FILE* text=fopen(snt_files->text_cod,"rb");
if (text==NULL) {
	error("Cannot open file %s\n",snt_files->text_cod);
	u_fclose(concor);
	return 1;
}
struct text_tokens* tok=load_text_tokens(snt_files->tokens_txt);
if (tok==NULL) {
	error("Cannot load text token file %s\n",snt_files->tokens_txt);
	u_fclose(concor);
	fclose(text);
	return 1;
}
FILE* f_enter=fopen(snt_files->enter_pos,"rb");
int n_enter_char;
if (f_enter==NULL) {
	error("Cannot open file %s\n",snt_files->enter_pos);
	n_enter_char=0;
}
else {
	n_enter_char=fread(&enter_pos,sizeof(int),MAX_ENTER_CHAR,f_enter);
   fclose(f_enter);
}
if (options->result_mode==INDEX_ || options->result_mode==UIMA_ || options->result_mode==AXIS_) { 
   /* We force some options for index, uima and axis files */
   options->left_context=0;
   options->right_context=0;
   options->sort_mode=TEXT_ORDER;
}

/* Once we have setted all the parameters, we call the function that
 * will actually create the concordance. */
create_concordance(concor,text,tok,n_enter_char,enter_pos,options);
u_fclose(concor);
fclose(text);
free_text_tokens(tok);
free_conc_opt(options);
u_printf("Done.\n");
return 0;
}

